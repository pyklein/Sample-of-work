<?php

/**
 * Dossier_mipTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class Dossier_mipTable extends Doctrine_Table {

  /**
   * Returns an instance of this class.
   *
   * @return Dossier_mipTable
   */
  public static function getInstance() {
    return Doctrine_Core::getTable('Dossier_mip');
  }

  /**
   *
   * @param DoctrineQuery $objRequeteDoctrine
   * @return DoctrineQuery requete Doctrine contenant les dossiers d'innovations (sans les pre-projets)
   */
  public function getDossierMIP($objRequeteDoctrine = null)
  {
    $objRequeteDoctrine = $this->createQuery('d')
                               ->where('statut_projet_mip_id = ?',Statut_projet_mipTable::DOSSIER_INNOV)
                               ->orderBy('d.created_at DESC');
    return $objRequeteDoctrine;
  }

  /**
   *
   * @param DoctrineQuery $objRequeteDoctrine
   * @return DoctrineQuery requete Doctrine contenant les dossiers necessitant un controle
   */
  public function getDossierMIPAControler($objRequeteDoctrine = null)
  {
    return $this->getDossierMIP($objRequeteDoctrine)->andWhere('necessite_controle != 0');
  }

  /**
   *
   * @param int $strPiloteId
   * @param DoctrineQuery $objRequeteDoctrine
   * @return DoctrineQuery requete Doctrine contenant les dossiers selon un pilote
   */
  public function getDossierMIPParPilote($strPiloteId,$objRequeteDoctrine = null)
  {
    return $this->getDossierMIP($objRequeteDoctrine)->andWhere('pilote_id=?',$strPiloteId)
                               ->orderBy('d.created_at DESC');
    
  }


  /**
   *  retourne la requête de base cherchant les dossiers MIP visibles sur l'interface publique
   * @return DoctrineQuery
   */
  public function getDossiersMIPPubliquesQuery(){
    return $this->createQuery('d')
                       ->where('d.statut_projet_mip_id = ?',Statut_projet_mipTable::DOSSIER_INNOV)
                       ->andWhere('d.est_actif = true')
                       ->andWhere('d.est_publie = true')
                       ->orderBy('d.created_at DESC');    
  }

    /**
   *  Methode proxy pour retrieveDossiersMIP() utilisée dans gridAction lors de filtres par modèle relatif
   * @param   DoctrineQuery $objRequeteDoctrine requête à trier
   * @return  DoctrineQuery requête Doctrine à passer au paginateur ou au filtre
   * Auteurs: William Richards
   */
  public function retrieveQuery($objRequeteDoctrine = null) {
    return $this->retrieveDossiersMIP($objRequeteDoctrine);
  }

  public function retrieveDossiersMIP($objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    return $objRequeteDoctrine->orderBy('numero');
  }

  /**
   *  Fourni des représentants cannoniques pour les années de création (widget Année Filtre)
   * @return DoctrineCollection liste des dossiers représentants canoniques
   *                            des années de création présentes en base
   * Auteur : William RICHARDS
   */
  public function getAnneesDossiers($objRequeteDoctrine = null) {

    if ($objRequeteDoctrine == null){
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();
    $arrDossiers = $objRequeteDoctrine->orderBy($rootAlias.'.created_at DESC')->execute();

    $arrAnnees = array();
    $arrDossiersCanon = new Doctrine_Collection('Dossier_mip');


    //recupération de l'année et ajout dans liste des années / liste canonique selon présence
    foreach ($arrDossiers as $objDossier) {
      $annee = $objDossier->getDateTimeObject('created_at')->format('Y');
      if (!in_array($annee, $arrAnnees)) {
        $arrAnnees[] = $annee;
        $arrDossiersCanon->add($objDossier);
      }
    }
    return $arrDossiersCanon;
  }

   /**
   *  Fourni des représentants cannoniques pour les années presentent dans les numéros de dossier
   * @return DoctrineCollection liste des dossiers représentants canoniques
   * des années de création présentes en base
   * Auteur : Antonin Kalk
   */
    public function getAnneesDossiersByNumero() {
      $arrDossiers = Doctrine_query::create()
        ->select('SUBSTRING(d.numero,1,4) AS sub')
        ->from('Dossier_mip d');
      
       $q = $arrDossiers->fetchArray();

      $arrAnnees = array();
      $arrAnnees['toutes'] = 'Toutes';
      //recupération de l'année et ajout dans liste des années 
      foreach ($q as $date) {
        if (!in_array($date['sub'], $arrAnnees)) {
          $arrAnnees[$date['sub']] = $date['sub'];
       }
      }
      // trie du tableau par clé dans l'ordre décroissant
      arsort($arrAnnees); 
      return $arrAnnees;
    }
    
  /**
   *  Ajoute le filtre par nom/prénom/email des innovateurs dans la requête de recherche des dossiers
   * @param Doctrine_Query      $objRequeteDoctrine   requête envoyée par le filtre
   * @param string              $strValeure           string a rechercher
   * @return Doctrine_Query                           requête retournée au filtre
   * Auteur : William RICHARDS
   */
  public function appliquerFiltreNomPrenomEmail(Doctrine_Query $objRequeteDoctrine, $strValeure) {
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $objRequeteDoctrine->innerJoin($rootAlias . '.Innovateur_dossier_mip i')
            ->innerJoin('i.Innovateur u')
            ->andWhere('(u.nom LIKE ?', '%' . $strValeure . '%')
            ->orWhere('u.prenom LIKE ?', '%' . $strValeure . '%')
            ->orWhere('u.email LIKE ?' . ')', '%' . $strValeure . '%');
    return $objRequeteDoctrine;
  }

  /**
   * Ajoute le filtre titre dans la requête de recherche des dossiers
   * @param Doctrine_Query      $objRequeteDoctrine   requête envoyée par le filtre
   * @param string              $strValeure           string a rechercher
   * @param string              $strOperateur         operateur
   * @return Doctrine_Query                           requête retournée au filtre
   * @author Gabor JAGER
   */
  public function appliquerFiltreTitre(Doctrine_Query $objRequeteDoctrine, $strValeure, $strOperateur) {
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $strValeure = str_replace("  ", " ", trim($strValeure));
    $arrValeurs = explode(" ", $strValeure);

    $strSql = "";
    foreach ($arrValeurs as $strVal) {
      $strSql .= ( $strSql == "" ? "" : $strOperateur) . " titre LIKE '%" . $strVal . "%' ";
    }

    $strSql = "(" . $strSql . ")";

    $objRequeteDoctrine->andWhere($strSql);

    return $objRequeteDoctrine;
  }

  /**
   * Ajoute le filtre titre dans la requête de recherche des dossiers
   * @param Doctrine_Query      $objRequeteDoctrine   requête envoyée par le filtre
   * @param string              $strValeure           string a rechercher
   * @param string              $strOperateur         operateur
   * @return Doctrine_Query                           requête retournée au filtre
   * @author Gabor JAGER
   */
  public function appliquerFiltreDescriptif(Doctrine_Query $objRequeteDoctrine, $strValeure, $strOperateur) {
    $strValeure = str_replace("  ", " ", trim($strValeure));
    $arrValeurs = explode(" ", $strValeure);

    $strSql = "";
    foreach ($arrValeurs as $strVal) {
      $strSql .= ( $strSql == "" ? "" : $strOperateur) . " descriptif LIKE '%" . $strVal . "%' ";
    }

    $strSql = "(" . $strSql . ")";

    $objRequeteDoctrine->andWhere($strSql);

    return $objRequeteDoctrine;
  }

  /**
   *  Ajoute le filtre par annee à la requête de recherche
   * @param Doctrine_Query  $objRequeteDoctrine   requête envoyée par le filtre
   * @param Id               $id                  Id du dossier Canon pour l'année choisie
   * @return Doctrine_Query                       requête retournée au filtre
   * Auteur : William RICHARDS
   */
  public function appliquerFiltreAnnee(Doctrine_Query $objRequeteDoctrine, $id) {
    $rootAlias = $objRequeteDoctrine->getRootAlias();
    $objDossier = $this->findOneById($id);
    if ($objDossier != false) {
      $annee = $objDossier->getDateTimeObject('created_at')->format('Y');
      $objRequeteDoctrine->andWhere($rootAlias . '.created_at >= ?', $annee . '-01-01 00:00:00');
      $objRequeteDoctrine->andWhere($rootAlias . '.created_at <= ?', $annee + 1 . '-01-01 00:00:00');
    }
    return $objRequeteDoctrine;
  }
  
  /**
   *  Ajoute le filtre par annee du numero à la requête de recherche
   * @param Doctrine_Query  $objRequeteDoctrine   requête envoyée par le filtre
   * @param Value           $value                Value de la date
   * @return Doctrine_Query                       requête retournée au filtre
   * Auteur : Antonin KALK
   */
  public function appliquerFiltreAnneeByNumero(Doctrine_Query $objRequeteDoctrine, $value) {
    $rootAlias = $objRequeteDoctrine->getRootAlias();
    if ($value != 'toutes')
      $objRequeteDoctrine->andwhere('SUBSTRING('.$rootAlias.'.numero,1,4) = ?',$value);
    
    return $objRequeteDoctrine;
  }

  /**
   *  Cherche le numéro d'incrément le plus élevé pour l'année en cours et le renvoi +1
   * @return string Incrément sur 3 chiffres calculé
   * Auteur: William RICHARDS
   */
  public function getIncrement() {
    $arrNumerosDossiersMIP = $this->createQuery('d')->select('numero')->execute();
    $strAnneeEnCours = date('Y');
    $intIncrementTest = 0;
    foreach ($arrNumerosDossiersMIP as $objNumeroDossierMIP) {
      $arrNumero = explode('/', $objNumeroDossierMIP->getNumero());
      $strAnnee = $arrNumero[0];
      $intIncrement = $arrNumero[1];
      if ($strAnnee == $strAnneeEnCours) {
        if ((int) $intIncrement > (int) $intIncrementTest) {
          $intIncrementTest = $intIncrement;
        }
      }
    }
    $intIncrementTest++;
    return str_pad($intIncrementTest, 3, '0', STR_PAD_LEFT);
  }

  /**
   *  Filtre la requête d'affichage des dossiers MIP en fonction des credentials
   * @param Doctrine_Query $objRequeteDoctrine  requête envoyée par le filtre
   * @param myUser         $objUtilisateur      utilisateur courant
   * @return Doctrine_Query                     requête finale
   */
  public function getRequeteListeParUtilisateur(Doctrine_Query $objRequeteDoctrine, myUser $objUtilisateur) {
    $strRootAlias = $objRequeteDoctrine->getRootAlias();
    if ($objUtilisateur->hasCredential('CLI-MIP')) {
      $objRequeteDoctrine->innerJoin($strRootAlias . '.Innovateur_dossier_mip i with i.utilisateur_id = ?', $objUtilisateur->getUtilisateur()->getId());
    }
    if ($objUtilisateur->hasCredential('COR-MIP')) {
      $objRequeteDoctrine->andWhere($strRootAlias . '.est_publie = 1');
    }
    return $objRequeteDoctrine;
  }

  /**
   *  Ajoute le filtre pour dossiers d'invention / préprojets
   * @param Doctrine_Query $objRequeteDoctrine
   * @param int $choix
   * @return Doctrine_Query
   */
  public function appliquerFiltreStatutProjet(Doctrine_Query $objRequeteDoctrine, $choix) {
    $rootAlias = $objRequeteDoctrine->getRootAlias();
    return $objRequeteDoctrine->andWhere($rootAlias . '.statut_projet_mip_id' . ($choix == 2 ? '!' : '' ) . '= 3');
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé avant la date echeance
   * d'etat d'avancement
   *
   * @param integer $intJoursAvantEcheance Nombre de jours avant echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceSurEtatAvancementAvant($intJoursAvantEcheance)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Echeance e ON e.dossier_mip_id = dm.id')
                    ->where('datediff(e.date_echeance_ea, sysdate()) <= ?',$intJoursAvantEcheance)
                    ->andWhere('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::AVANT_ETAT_AVANCEMENT)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé apres la date echeance
   * d'etat d'avancement
   *
   * @param integer $intJoursApresEcheance Nombre de jours apres echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceSurEtatAvancementApres($intJoursApresEcheance)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Echeance e ON e.dossier_mip_id = dm.id')
                    ->where('datediff(sysdate(), e.date_echeance_ea) >= ?',$intJoursApresEcheance)
                    ->andWhere('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::APRES_ETAT_AVANCEMENT)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé avant la date echeance
   * du compte rendu
   *
   * @param integer $intJoursAvantEcheance Nombre de jours avant echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceSurCompteRenduAvant($intJoursAvantEcheance)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Echeance e ON e.dossier_mip_id = dm.id')
                    ->where('datediff(e.date_echeance_cr, sysdate()) <= ?',$intJoursAvantEcheance)
                    ->andWhere('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::AVANT_COMPT_RENDU)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé apres la date echeance
   * du compte rendu
   *
   * @param integer $intJoursApresEcheance Nombre de jours apres echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceSurCompteRenduApres($intJoursApresEcheance)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Echeance e ON e.dossier_mip_id = dm.id')
                    ->where('datediff(sysdate(), e.date_echeance_cr) >= ?',$intJoursApresEcheance)
                    ->andWhere('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::APRES_COMPT_RENDU)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé apres demande d'avis
   * d'etat major mais sans reponse
   *
   * @param integer $intJoursApresEnvoiDemand Nombre de jours apres echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceApresEnvoieEtatMajeur($intJoursApresEnvoiDemand)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Avis_etatmajor aem ON (aem.dossier_mip_id = dm.id AND (datediff(sysdate(),aem.date_demande) >= ?) AND (aem.date_reception IS NULL))',$intJoursApresEnvoiDemand)
                    ->where('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::APRES_ENVOI_ETAT_MAJEUR)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  /**
   * Recupere les dossier MIP qui doivent etre relancé apres emition d'un avis
   * favorable d'etat major mais sans lettre de soutien remis
   *
   * @param integer $intJoursApresRecuAvis Nombre de jours apres echeance
   * @return Doctrine_Collection
   *
   * @author Simeon PETEV
   */
  public function retreveDossiersPourRelanceApresRecuAvisFavorable($intJoursApresRecuAvis)
  {
    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ DEBUT; ");

    $objQuery = $requete = $this->createQuery()
                    ->from('Dossier_mip dm')
                    ->innerJoin('dm.Avis_etatmajor aem ON (aem.dossier_mip_id = dm.id AND (aem.est_favorable = TRUE) AND (datediff(sysdate(),aem.date_reception) >= ?))',$intJoursApresRecuAvis)
                    ->where('dm.id NOT IN (SELECT doc.dossier_mip_id FROM documents_mip doc WHERE doc.documents_mip_type_id = ?)',  Documents_mipTable::LETTRE_SOUTIEN)
                    ->andWhere('dm.id NOT IN (SELECT rd.dossier_mip_id FROM relance_dossier_mip as rd WHERE rd.type_relance_dossier_mip_id = ?)',  Type_relance_dossier_mipTable::APRES_RECU_AVIS_FAVORABLE)
    ;

    if (sfContext::hasInstance())
      sfContext::getInstance()->getLogger()->debug("{".__CLASS__."} [".__FUNCTION__."] /Ligne: ".__LINE__."/ FIN; ");

    return $objQuery->execute();
  }

  //Methodes Statistiques

  /**
   *  retrieveStatistiquesQuery
   * @return Doctrine_Query Requete de base pour le filtre de l'écran statistique
   * @author William Richards
   */
  public function retrieveStatistiquesQuery() {
    $objRequeteDoctrine = Doctrine_Query::create()
                    ->select('d.id')
                    ->from('Dossier_mip d')
                    ->where('d.statut_projet_mip_id = 3')
    ;
    return $objRequeteDoctrine;
  }

  /**
   *  getCountsByX retourne une array('clef' => 'compte') donnant le nombre de dossier par clef
   *  getCountByX  retourne le compte correspondant au nombre de dossiers selon une condition
   * @param Doctrine_Query $objRequeteDoctrine Requête donnée par le filtre statistique donnant la liste de dossiers
   *                                           sur laquelle les statistique doivent être faites
   * @return array voir ci-dessus
   *
   * note: getCountsByDate retourne une array('annee' => array('ouvert' => compte,'clos' => compte))
   *
   * @author William Richards
   */
  public function getCountsByStatuts(Doctrine_Query $objRequeteDoctrine = null) {
    $arrResults = array();
    foreach (Statut_dossier_mipTable::getInstance()->findAll() as $statut) {
      $arrResults[$statut->getIntitule()] = $this->getCountByStatut($statut->getId(), $objRequeteDoctrine);
    }
    return $arrResults;
  }

  protected function getCountByStatut($intId, Doctrine_Query $objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $result = clone $objRequeteDoctrine;
    $result->andWhere($rootAlias . '.statut_dossier_mip_id = ?', $intId);

    return $result->execute()->count();
  }

  public function getCountsByNiveaux(Doctrine_Query $objRequeteDoctrine = null) {
    $arrResults = array();
    foreach (Niveau_protectionTable::getInstance()->findAll() as $niveau) {
      $arrResults[$niveau->getIntitule()] = $this->getCountByNiveau($niveau->getId(), $objRequeteDoctrine);
    }
    return $arrResults;
  }

  protected function getCountByNiveau($intId, Doctrine_Query $objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $result = clone $objRequeteDoctrine;
    $result->andWhere($rootAlias . '.niveau_protection_id = ?', $intId);

    return $result->execute()->count();
  }

  public function getCountsByOrganismesMindef(Doctrine_Query $objRequeteDoctrine = null) {
    $arrResults = array();
    foreach (Organisme_mindefTable::getInstance()->retrieveOrganismesMindefActif() as $organisme) {
      $arrResults[$organisme->getIntitule()] = $this->getCountByOrganismesMindef($organisme->getId(), $objRequeteDoctrine);
    }
    return $arrResults;
  }

  protected function getCountByOrganismesMindef($intId, Doctrine_Query $objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $result = clone $objRequeteDoctrine;
    $result->andWhere($rootAlias . '.organisme_mindef_id = ?', $intId);

    return $result->execute()->count();
  }

  public function getCountsByAnnees(Doctrine_Query $objRequeteDoctrine = null) {
    $arrResults = array();
    foreach ($this->getAnneesBascules($objRequeteDoctrine) as $annee) {
      $arrResults[$annee] = array(
          'ouvert' => $this->getCountOuvertByAnnee($annee, $objRequeteDoctrine),
          'clos' => $this->getCountClosByAnnee($annee, $objRequeteDoctrine)
      );
    }
    return $arrResults;
  }

  protected function getCountClosByAnnee($strAnnee, Doctrine_Query $objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $dateMin = $strAnnee . '-01-01 00:00:00';
    $dateMax = ($strAnnee + 1) . '-01-01 00:00:00';

    $result = clone $objRequeteDoctrine;

    $result->innerJoin($rootAlias . '.Transfert_cloture t on t.dossier_mip_id = ' . $rootAlias . '.id')
            ->andWhere('(t.date_transfert >= ? AND t.date_transfert <= ?) OR (t.date_cloture >= ? AND t.date_cloture <= ?)', array($dateMin, $dateMax, $dateMin, $dateMax));

    return $result->execute()->count();
  }

  protected function getCountOuvertByAnnee($strAnnee, Doctrine_Query $objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $dateMin = $strAnnee . '-01-01 00:00:00';
    $dateMax = ($strAnnee + 1) . '-01-01 00:00:00';


    $result = clone $objRequeteDoctrine;
    $result->andWhere($rootAlias . '.date_bascule >= ?', $dateMin)->andWhere($rootAlias . '.date_bascule <= ?', $dateMax);
    return $result->execute()->count();
  }

  /**
   *  Fourni la liste des années ou des dossiers ont été créés ou basculés
   * @return array  liste des années de création présentes en base
   * Auteur : William RICHARDS
   */
  public function getAnneesBascules($objRequeteDoctrine = null) {
    if ($objRequeteDoctrine == null){
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();
    $result = clone $objRequeteDoctrine;
    $result = $result->andWhere($rootAlias.'.statut_projet_mip_id = 3')->orderBy($rootAlias.'.date_bascule DESC');
    $arrDossiers = $result->execute();
    $arrAnnees = array();


    //recupération de l'année et ajout dans liste des années / liste canonique selon présence
    foreach ($arrDossiers as $objDossier) {
      if (strlen($objDossier->getDateTimeObject('date_bascule')->format('Y')) == 4)
        $annee = $objDossier->getDateTimeObject('date_bascule')->format('Y');
      if (!in_array($annee, $arrAnnees)) {
        $arrAnnees[] = $annee;
      }
    }
    return $arrAnnees;
  }

  /**
   *  Verifie les etats de contrôle pour tous les dossiers envoyés par la requête
   * @param <type> $objRequeteDoctrine
   * @return <type>
   */
  public function getCountsByEtatsControle($objRequeteDoctrine) {
    $arrResults = array();
    $arrResults[libelle('msg_statistiques_aucun_avertissement_controle')] = $this->getCountByEtatControle(0, $objRequeteDoctrine);
    $arrResults[libelle('msg_statistiques_avertissements_controle')] = $this->getCountByEtatControle(1, $objRequeteDoctrine);
    $arrResults[libelle('msg_statistiques_erreurs_controle')] = $this->getCountByEtatControle(2, $objRequeteDoctrine);
    return $arrResults;
   
  }

  public function getCountByEtatControle($intEtat,$objRequeteDoctrine) {
        if ($objRequeteDoctrine == null) {
      $objRequeteDoctrine = $this->createQuery();
    }
    $rootAlias = $objRequeteDoctrine->getRootAlias();

    $result = clone $objRequeteDoctrine;
    $result->andWhere($rootAlias . '.necessite_controle = ?', $intEtat);

    return $result->execute()->count();
  }

  public function getCountsByBrevets($objRequeteDoctrine) {
    $collection = $objRequeteDoctrine->execute();
    $intSansBPI = 0;
    $intAvecBPISansBrevet = 0;
    $intAvecBPIAvecUnBrevet = 0;
    $intAvecBPIAvecBrevets = 0;

    //recherche de présence de brevets
    if ($collection->count() > 0) {
      foreach ($collection as $objDossierMIP) {
        if ($dossiersBPI = $objDossierMIP["DossiersBPI"]) {
          if ($dossiersBPI->count() > 0) {
            $intBrevets = 0;
            foreach ($dossiersBPI as $dossierBPI) {
              if ($dossierBPI->getBrevet() != null) {
                $intBrevets += $dossierBPI->getBrevet()->count();
              }
            }
            if ($intBrevets == 0) {
              $intAvecBPISansBrevet++;
              continue;
            }
            if ($intBrevets == 1) {
              $intAvecBPIAvecUnBrevet++;
              continue;
            }
            if ($intBrevets > 1) {
              $intAvecBPIAvecBrevets++;
              continue;
            }
          } else {
            $intSansBPI++;
            continue;
          }
        }
      }
    }
    return array(
        libelle('msg_statistiques_aucune_liaison') => $intSansBPI,
        libelle('msg_statistiques_avec_liaison') => $intAvecBPISansBrevet + $intAvecBPIAvecUnBrevet + $intAvecBPIAvecBrevets,
        libelle('msg_statistiques_avec_liaison_aucun_brevet') => $intAvecBPISansBrevet,
        libelle('msg_statistiques_avec_liaison_un_brevet') => $intAvecBPIAvecUnBrevet,
        libelle('msg_statistiques_avec_liaison_des_brevets') => $intAvecBPIAvecBrevets
    );
  }

  //Fin methodes statistiques

  /**
   * Recupere les dossier disponibles
   * @param string $strSessionToken
   * @param string $strDossierBpiId
   * @return Doctrine_Query
   * @author William
   */
  public function retrieveDossierMIPDisponibles($strSessionToken,$strDossierBpiId){
    $objRequeteDoctrine = $this->createQuery('d')
                               ->where('d.est_actif = 1')->andWhere('d.etat_partage_id = 3')
                               ->leftJoin('d.Session_liaison_dossiers_bpi_mip s WITH s.dossier_mip_id = d.id and s.transaction_token = ?',$strSessionToken)
                               ->andWhere('s.est_concerne = 0 OR s.transaction_token is null')
                               ->leftJoin('d.Dossier_mip_dossier_bpi l on l.dossier_mip_id = d.id and l.dossier_bpi_id = ?',$strDossierBpiId)
                               ->andWhere('l.dossier_mip_id != d.id OR l.dossier_bpi_id is null')
                               ->orWhere('s.est_concerne = 0')
            ;
     return $objRequeteDoctrine->orderBy('d.numero');
  }

  /**
   * Recupere les dossiers concernés
   * @param string $strSessionToken
   * @param string $strDossierbpiId
   * @return Doctrine_Query
   * @author William
   */
  public function retrieveDossierMIPConcernes($strSessionToken,$strDossierBpiId){
    $objRequeteDoctrine = $this->createQuery('d')
                               ->where('d.est_actif = 1')
                               ->leftJoin('d.Session_liaison_dossiers_bpi_mip s WITH s.dossier_mip_id = d.id and s.transaction_token = ?',$strSessionToken)
                               ->andWhere('s.est_concerne = 1 OR s.transaction_token is null')
                               ->leftJoin('d.Dossier_mip_dossier_bpi l on l.dossier_mip_id = d.id')
                               ->andWhere('l.dossier_bpi_id = ? OR l.dossier_bpi_id is null',$strDossierBpiId)
                               ->andWhere('NOT (l.dossier_bpi_id is null AND s.transaction_token is null)')
                               ->orWhere('s.est_concerne = ?','1')
            ;
     return $objRequeteDoctrine->orderBy('d.numero');
  }

  /**
   * Retourne les dossiers MIP liés a un dossier BPI
   * @param int $intDossierBpiId   Identifiant du dossier BPI
   */
  public function retrieveDossiersMipByDossierBpi($intDossierBpiId) {
    $objRequeteDoctrine = $this->createQuery('d')
                        ->leftJoin('d.Dossier_mip_dossier_bpi r on r.dossier_mip_id = d.id')
                        ->where('r.dossier_bpi_id = ?', $intDossierBpiId);
    return $objRequeteDoctrine;
  }
}